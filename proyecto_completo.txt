===== main.py =====

"""
Visualizador de Algoritmos Genéticos
-----------------------------------
Aplicación para visualizar el funcionamiento de algoritmos genéticos
en la resolución de problemas de optimización de funciones.
"""

import sys
from PySide6.QtWidgets import QApplication, QMessageBox
from ui.main_window import MainWindow  # Debes crear esta versión Qt de tu ventana principal

from manager.ga_manager import get_ga_instance, get_available_ga_names

SELECTED_GA_NAME = "example_ga"  # O "standard_ga" para probar el otro

def execute_specific_ga(params: dict, root_qt_window=None, algorithm_name: str = SELECTED_GA_NAME):
    """
    Ejecuta un AG específico y devuelve los resultados en el formato esperado por MainWindow.
    """
    print(f"Solicitando ejecución del AG: '{algorithm_name}'")
    print("Recibidos parámetros para el AG:", params)

    try:
        ga_instance = get_ga_instance(algorithm_name)
    except ValueError as e:
        QMessageBox.critical(root_qt_window, "Error de Configuración", f"No se pudo cargar el AG: {e}")
        print(f"Error cargando el AG: {e}")
        return None

    try:
        results = ga_instance.run(
            x_min=params['interval_a'],
            x_max=params['interval_b'],
            delta_x=params['delta_x'],
            pop_size=params['pop_size'],
            max_generations=params['num_generations'],
            prob_crossover=params['prob_crossover'],
            prob_mutation_i=params['prob_mutation_i'],
            prob_mutation_g=params['prob_mutation_g'],
            is_minimizing=params['is_minimizing'],
            progress_root_window=root_qt_window  # Qt parent para diálogos de progreso
        )
        return results
    except Exception as e:
        QMessageBox.critical(root_qt_window, "Error en AG", f"Falló la ejecución del AG '{algorithm_name}': {e}")
        print(f"Error ejecutando el AG '{algorithm_name}': {e}")
        import traceback
        traceback.print_exc()
        return None

def main():
    app = QApplication(sys.argv)
    try:
        with open("style.qss", "r") as f:
            app.setStyleSheet(f.read())
    except FileNotFoundError:
        print("Warning: style.qss not found. Using default styles.")

    print(f"Nombres de AGs disponibles: {get_available_ga_names()}")
    print(f"AG seleccionado para esta sesión: {SELECTED_GA_NAME}")

    if SELECTED_GA_NAME not in get_available_ga_names():
        print(f"Error: El AG '{SELECTED_GA_NAME}' no está registrado. Usando 'example_ga' por defecto.")
        actual_ga_to_use = "example_ga"
        if "example_ga" not in get_available_ga_names():
            QMessageBox.critical(None, "Error Crítico", "No hay ningún AG 'example_ga' registrado. La aplicación no puede continuar.")
            return
    else:
        actual_ga_to_use = SELECTED_GA_NAME

    main_window = MainWindow()  # Debe ser tu ventana principal basada en PySide6

    configured_ga_executor = lambda p, r: execute_specific_ga(p, r, algorithm_name=actual_ga_to_use)
    main_window.set_ga_executor(configured_ga_executor)

    main_window.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
===== ui/main_window.py =====

# ===== ./ui/main_window.py =====

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Ventana principal de la aplicación - Visualizador de Resultados de AG (Versión PySide6)
"""

from PySide6.QtWidgets import QMainWindow, QWidget, QSplitter, QMessageBox, QVBoxLayout, QFileDialog, QProgressDialog
from PySide6.QtCore import Qt, QUrl
from PySide6.QtGui import QDesktopServices

# Asegúrate de que estas importaciones apunten a las versiones PySide6 de tus paneles
from ui.config_panel import ConfigPanel
from ui.visualization_panel import VisualizationPanel
from utils.export import ReportGenerator, AnimationGenerator
from utils.math_functions import set_function_provider
# Asegúrate que CustomFunctionProvider es la versión adaptada para PySide6/Sympy
from ui.function_editor import CustomFunctionProvider, FunctionEditor
from utils.helpers import open_file # Usaremos el helper para abrir archivos

class MainWindow(QMainWindow):
    """Clase principal que maneja la ventana y coordina los componentes (PySide6)"""

    def __init__(self):
        """Inicializa la ventana principal y sus componentes"""
        super().__init__()
        self.setWindowTitle("Algoritmo Genético - Visualizador de Resultados (PySide6)")
        self.setGeometry(100, 100, 1400, 800)
        self.setMinimumSize(1000, 600)

        self.ga_results = None
        self.population_history = []
        self.fitness_history = []
        self.best_fitness_history = []

        self.report_generator = ReportGenerator()
        self.animation_generator = AnimationGenerator()
        self.ui_function_provider = CustomFunctionProvider() # Esta es tu clase adaptada
        set_function_provider(self.ui_function_provider)

        self.ga_executor = None

        self.create_interface()

    def create_interface(self):
        """Crea la interfaz dividida en dos paneles usando QSplitter"""
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)

        self.main_splitter = QSplitter(Qt.Horizontal)
        main_layout.addWidget(self.main_splitter)

        # Panel izquierdo (Configuración)
        # Creamos un QWidget que actuará como contenedor para el ConfigPanel
        self.left_pane_container = QWidget()
        left_layout = QVBoxLayout(self.left_pane_container) # Layout para el contenedor
        left_layout.setContentsMargins(0,0,0,0) # Para que ConfigPanel lo llene
        # ConfigPanel se añade a este QWidget contenedor
        self.config_panel = ConfigPanel(self.left_pane_container, self, self.ui_function_provider)
        left_layout.addWidget(self.config_panel)
        self.main_splitter.addWidget(self.left_pane_container)

        # Panel derecho (Visualización)
        self.right_pane_container = QWidget()
        right_layout = QVBoxLayout(self.right_pane_container)
        right_layout.setContentsMargins(0,0,0,0)
        self.visualization_panel = VisualizationPanel(self.right_pane_container, self)
        right_layout.addWidget(self.visualization_panel)
        self.main_splitter.addWidget(self.right_pane_container)

        # Ajustar tamaños iniciales y políticas de expansión
        self.main_splitter.setSizes([420, self.width() - 450]) # Tamaños iniciales aproximados
        self.main_splitter.setStretchFactor(0, 0) # Panel izquierdo no se estira tanto
        self.main_splitter.setStretchFactor(1, 1) # Panel derecho se estira más

    def run_example_algorithm(self, params: dict):
        """Ejecuta el algoritmo genético configurado con los parámetros proporcionados"""
        if not self.ga_executor:
            QMessageBox.critical(self, "Error", "No se ha configurado un ejecutor de Algoritmo Genético.")
            return

        # Mostrar un diálogo de progreso simple
        progress_dialog = QProgressDialog("Ejecutando AG...", "Cancelar", 0, 0, self)
        progress_dialog.setWindowModality(Qt.WindowModal)
        progress_dialog.setWindowTitle("Procesando")
        progress_dialog.show()
        # QApplication.processEvents() # Para que se muestre inmediatamente

        try:
            # Pasamos 'self' (la QMainWindow) como ventana padre para el AG,
            # por si el AG necesita crear sus propios diálogos de progreso Qt.
            results = self.ga_executor(params, self)

            if results is None:
                progress_dialog.close()
                return

            self.ga_results = results['ga_results']
            self.population_history = results['population_history']
            self.fitness_history = results['fitness_history']
            self.best_fitness_history = results['best_fitness_history']

            # Actualizar la función en la UI si el AG la reporta
            function_text_from_ga = self.ga_results.get('function_text_for_report')
            if function_text_from_ga:
                # Usamos el FunctionEditor de PySide6 para validar y obtener la función compilada
                temp_editor = FunctionEditor(self) # 'self' es el padre QMainWindow
                temp_editor.function_entry.setText(function_text_from_ga) # Asumimos que FunctionEditor tiene 'function_entry'
                is_valid = temp_editor.validate_function()
                if is_valid:
                    # Asumimos que validate_function en FunctionEditor actualiza self.compiled_function_result
                    self.ui_function_provider.set_function(function_text_from_ga, temp_editor.compiled_function_result)
                    self.config_panel.update_function_display() # ConfigPanel debe tener este método
                else:
                    QMessageBox.critical(self, "Error de Función",
                                         "La función reportada por el AG no pudo ser validada por la UI.")
                # temp_editor.destroy() # No es necesario, se cierra con el scope o si es modal
            else:
                QMessageBox.warning(self, "Advertencia", "El AG no reportó la función objetivo utilizada.")

            self.config_panel.enable_buttons() # ConfigPanel debe tener este método
            mode_text = "Minimización" if params['is_minimizing'] else "Maximización"
            QMessageBox.information(self, "Completado",
                                f"Algoritmo de ejemplo completado! ({mode_text})\n\n"
                                f"Mejor solución: x = {self.ga_results['best_x']:.6f}\n"
                                f"Mejor fitness (real): f(x) = {self.ga_results['best_fitness']:.6f}")

        except Exception as e:
            QMessageBox.critical(self, "Error en AG", f"Error durante la ejecución del AG: {str(e)}")
            import traceback
            traceback.print_exc()
        finally:
            progress_dialog.close()


    def generate_report(self): # Ya no necesita 'filename' como argumento directo
        if not self.ga_results:
            QMessageBox.warning(self, "Advertencia", "No hay resultados para generar el reporte.")
            return False

        # Usar QFileDialog para obtener el nombre del archivo
        filename, selected_filter = QFileDialog.getSaveFileName(
            self,
            "Guardar Reporte",
            "", # Directorio inicial (opcional)
            "Text files (*.txt);;All files (*.*)"
        )
        if not filename: # El usuario canceló
            return False

        try:
            self.report_generator.generate(
                filename,
                self.ga_results,
                self.best_fitness_history
            )
            QMessageBox.information(self, "Reporte Guardado", f"Reporte guardado en:\n{filename}")
            if QMessageBox.question(self, "Abrir Reporte", "¿Desea abrir el reporte generado?") == QMessageBox.Yes:
                open_file(filename) # Usar el helper
            return True
        except Exception as e:
            QMessageBox.critical(self, "Error de Reporte", f"Error al generar el reporte: {str(e)}")
            return False


    def save_animation(self): # Ya no necesita 'filename' como argumento directo
        if not self.ga_results:
            QMessageBox.warning(self, "Advertencia", "Primero debe ejecutar el algoritmo.")
            return False

        filename, selected_filter = QFileDialog.getSaveFileName(
            self,
            "Guardar Animación",
            "",
            "MP4 files (*.mp4);;GIF files (*.gif);;All files (*.*)"
        )
        if not filename:
            return False

        try:
            # El AnimationGenerator ya maneja su propio diálogo de progreso y QMessageBox
            # Pasamos 'self' como ventana raíz para que los diálogos del generador sean modales a esta.
            success = self.animation_generator.generate(
                filename,
                self.best_fitness_history,
                self.ga_results['is_minimizing'],
                self # QWidget padre para los diálogos del AnimationGenerator
            )
            # Nota: AnimationGenerator debería mostrar su propio QMessageBox de éxito/error
            return success
        except Exception as e:
            # Esto es un fallback si AnimationGenerator no maneja su propia excepción
            QMessageBox.critical(self, "Error de Animación", f"Error al generar la animación: {str(e)}")
            return False


    def clear_results(self):
        self.ga_results = None
        self.population_history = []
        self.fitness_history = []
        self.best_fitness_history = []
        self.visualization_panel.clear_graph_area()
        self.visualization_panel.create_welcome_message() # Recrear mensaje de bienvenida
        self.config_panel.disable_buttons() # ConfigPanel debe tener este método
        QMessageBox.information(self, "Resultados Limpiados", "Todos los resultados han sido limpiados.")

    # El método run() ya no es necesario aquí, QApplication.exec() en main.py lo maneja.

    def set_ga_executor(self, executor_func):
        self.ga_executor = executor_func
===== ui/config_panel.py =====

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Panel de configuración de la aplicación
"""
from PySide6.QtWidgets import QWidget, QVBoxLayout, QScrollArea, QDoubleSpinBox, QPushButton, QLabel, QMessageBox
from PySide6.QtUiTools import QUiLoader
from PySide6.QtCore import QFile, QIODevice
from utils.math_functions import set_function_provider

class ConfigPanel(QWidget):
    """Clase que maneja el panel de configuración (izquierdo)"""
    
    def __init__(self, parent_widget, main_window, function_provider_instance):
        super().__init__(parent_widget)  # parent_widget debe ser QWidget o None
        self.main_window = main_window
        self.function_provider = function_provider_instance
        set_function_provider(self.function_provider)

        self.init_ui_from_designer()

        # Conecta señales de los widgets cargados desde el archivo .ui
        if hasattr(self, 'interval_a_spinbox') and self.interval_a_spinbox:
            self.interval_a_spinbox.valueChanged.connect(self.update_calculated_values)
        if hasattr(self, 'editFunctionButton') and self.editFunctionButton:
            self.editFunctionButton.clicked.connect(self.open_function_editor)
        if hasattr(self, 'execute_ag_btn') and self.execute_ag_btn:
            self.execute_ag_btn.clicked.connect(self.run_example_algorithm_from_config)

        self.update_function_display()
        self.update_calculated_values()
        self.disable_buttons()

    def init_ui_from_designer(self):
        outer_layout = QVBoxLayout(self)
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        outer_layout.addWidget(scroll_area)

        loader = QUiLoader()
        ui_file_path = "ui/config_panel.ui"  # Cambia si tu ruta es diferente
        ui_file = QFile(ui_file_path)

        if not ui_file.open(QIODevice.ReadOnly):
            print(f"Cannot open UI file: {ui_file_path} - {ui_file.errorString()}")
            QMessageBox.critical(self, "UI Load Error", f"Could not load {ui_file_path}")
            return

        self.scrollable_widget_content = loader.load(ui_file, self)
        ui_file.close()

        if not self.scrollable_widget_content:
            print(f"Error loading UI file {ui_file_path}: {loader.errorString()}")
            QMessageBox.critical(self, "UI Load Error", f"Error parsing {ui_file_path}: {loader.errorString()}")
            return

        scroll_area.setWidget(self.scrollable_widget_content)

        # Accede a los widgets por su objectName definido en Qt Designer
        self.interval_a_spinbox = self.scrollable_widget_content.findChild(QDoubleSpinBox, "interval_a_spinbox")
        self.interval_b_spinbox = self.scrollable_widget_content.findChild(QDoubleSpinBox, "interval_b_spinbox")
        self.function_display_label = self.scrollable_widget_content.findChild(QLabel, "functionDisplayLabel")
        self.editFunctionButton = self.scrollable_widget_content.findChild(QPushButton, "editFunctionButton")
        self.execute_ag_btn = self.scrollable_widget_content.findChild(QPushButton, "execute_ag_btn")

        # Puedes agregar más findChild para otros widgets según los objectName en tu .ui

        if not self.interval_a_spinbox:
            print("Warning: interval_a_spinbox not found in .ui file or objectName mismatch.")
        if not self.execute_ag_btn:
            print("Warning: execute_ag_btn not found in .ui file or objectName mismatch.")

    def open_function_editor(self):
        # MODIFICADO: Importar FunctionEditor dentro del método
        from ui.function_editor import FunctionEditor
        
        def on_function_accept(function_text, compiled_function):
            self.function_provider.set_function(function_text, compiled_function)
            set_function_provider(self.function_provider)
            self.update_function_display()
            QMessageBox.information(self, "Función Actualizada", 
                              "La función objetivo ha sido actualizada para el visualizador y el AG de ejemplo.")
        
        FunctionEditor(self, on_function_accept, initial_function=self.function_provider.function_text)

    def update_function_display(self):
        if hasattr(self, 'function_display_label') and self.function_provider:
            function_text = self.function_provider.function_text
            display_text = function_text.replace('*', '·')
            self.function_display_label.setText(f"f(x) = {display_text}")

    def update_calculated_values(self):
        try:
            x_min = self.interval_a_spinbox.value()
            x_max = self.interval_b_spinbox.value()
            delta_x = self.delta_x_spinbox.value()
            if x_max > x_min and delta_x > 0:
                # MODIFICADO: Simplificado el cálculo de n_bits como en el AG.
                # Este cálculo es principalmente para visualización en la UI,
                # el AG debe realizar su propio cálculo exacto.
                if x_min == 0 and x_max == 31 and delta_x == 1.0: # Caso especial para coincidir con AG
                    n_bits = 5
                elif x_min >= 0 and x_max == int(x_max) and delta_x == 1.0: # Otro caso para rangos enteros
                    range_size = int(x_max - x_min) + 1
                    n_bits = int((range_size - 1).bit_length())
                else: # Cálculo general
                    num_divisions = int(round((x_max - x_min) / delta_x)) # Usar round para evitar problemas de flotantes
                    n_bits = int((num_divisions + 1).bit_length()) if num_divisions >= 0 else 0 # +1 para incluir el punto final
                
                if n_bits < 1: n_bits = 1 # Asegurar al menos 1 bit

                max_decimal = 2 ** n_bits - 1
                num_points = max_decimal + 1 # O num_divisions + 1 para el cálculo general
                
                self.num_points_label.setText(str(num_points))
                self.num_bits_label.setText(str(n_bits))
                self.max_decimal_label.setText(str(max_decimal))
            else:
                self.num_points_label.setText("...")
                self.num_bits_label.setText("...")
                self.max_decimal_label.setText("...")
        except Exception:
            self.num_points_label.setText("Error")
            self.num_bits_label.setText("Error")
            self.max_decimal_label.setText("Error")


    def run_example_algorithm_from_config(self):
        x_min = self.interval_a_spinbox.value()
        x_max = self.interval_b_spinbox.value()
        delta_x = self.delta_x_spinbox.value()
        pop_size_val = self.pop_size_spinbox.value()
        num_generations_val = self.num_generations_spinbox.value()
        prob_crossover_val = self.prob_crossover_spinbox.value()
        prob_mutation_i_val = self.prob_mutation_i_spinbox.value()
        prob_mutation_g_val = self.prob_mutation_g_spinbox.value()
        is_minimizing = self.minimize_radio.isChecked()

        if x_min >= x_max:
            QMessageBox.critical(self, "Error", "El intervalo [a,b] no es válido. a debe ser menor que b.")
            return
        if delta_x <= 0:
            QMessageBox.critical(self, "Error", "Δx debe ser mayor que 0.")
            return

        params = {
            'interval_a': x_min, 'interval_b': x_max, 'delta_x': delta_x,
            'pop_size': int(pop_size_val),
            'num_generations': int(num_generations_val),
            'prob_crossover': prob_crossover_val,
            'prob_mutation_i': prob_mutation_i_val,
            'prob_mutation_g': prob_mutation_g_val,
            'is_minimizing': is_minimizing
        }
        self.main_window.run_example_algorithm(params)

    def enable_buttons(self):
        # Implementa según tus botones
        pass

    def disable_buttons(self):
        # Implementa según tus botones
        pass

    def clear_results(self):
        self.main_window.clear_results()
        # self.update_button_selection("none")

class Frame(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        # ... tu inicialización ...