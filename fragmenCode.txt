===== ui/main_window.py =====

# ===== ./ui/main_window.py =====

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Ventana principal de la aplicación - Visualizador de Resultados de AG (Versión PySide6)
"""

from PySide6.QtWidgets import QMainWindow, QWidget, QSplitter, QMessageBox, QVBoxLayout, QFileDialog, QProgressDialog
from PySide6.QtCore import Qt, QUrl
from PySide6.QtGui import QDesktopServices

# Asegúrate de que estas importaciones apunten a las versiones PySide6 de tus paneles
from ui.config_panel import ConfigPanel
from ui.visualization_panel import VisualizationPanel
from utils.export import ReportGenerator, AnimationGenerator
from utils.math_functions import set_function_provider
# Asegúrate que CustomFunctionProvider es la versión adaptada para PySide6/Sympy
from ui.function_editor import CustomFunctionProvider, FunctionEditor
from utils.helpers import open_file # Usaremos el helper para abrir archivos

class MainWindow(QMainWindow):
    """Clase principal que maneja la ventana y coordina los componentes (PySide6)"""

    def __init__(self):
        """Inicializa la ventana principal y sus componentes"""
        super().__init__()
        self.setWindowTitle("Algoritmo Genético - Visualizador de Resultados (PySide6)")
        self.setGeometry(100, 100, 1400, 800)
        self.setMinimumSize(1000, 600)

        self.ga_results = None
        self.population_history = []
        self.fitness_history = []
        self.best_fitness_history = []

        self.report_generator = ReportGenerator()
        self.animation_generator = AnimationGenerator()
        self.ui_function_provider = CustomFunctionProvider() # Esta es tu clase adaptada
        set_function_provider(self.ui_function_provider)

        self.ga_executor = None

        self.create_interface()

    def create_interface(self):
        """Crea la interfaz dividida en dos paneles usando QSplitter"""
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)

        self.main_splitter = QSplitter(Qt.Horizontal)
        main_layout.addWidget(self.main_splitter)

        # Panel izquierdo (Configuración)
        # Creamos un QWidget que actuará como contenedor para el ConfigPanel
        self.left_pane_container = QWidget()
        left_layout = QVBoxLayout(self.left_pane_container) # Layout para el contenedor
        left_layout.setContentsMargins(0,0,0,0) # Para que ConfigPanel lo llene
        # ConfigPanel se añade a este QWidget contenedor
        self.config_panel = ConfigPanel(self.left_pane_container, self, self.ui_function_provider)
        left_layout.addWidget(self.config_panel)
        self.main_splitter.addWidget(self.left_pane_container)

        # Panel derecho (Visualización)
        self.right_pane_container = QWidget()
        right_layout = QVBoxLayout(self.right_pane_container)
        right_layout.setContentsMargins(0,0,0,0)
        self.visualization_panel = VisualizationPanel(self.right_pane_container, self)
        right_layout.addWidget(self.visualization_panel)
        self.main_splitter.addWidget(self.right_pane_container)

        # Ajustar tamaños iniciales y políticas de expansión
        self.main_splitter.setSizes([420, self.width() - 450]) # Tamaños iniciales aproximados
        self.main_splitter.setStretchFactor(0, 0) # Panel izquierdo no se estira tanto
        self.main_splitter.setStretchFactor(1, 1) # Panel derecho se estira más

    def run_example_algorithm(self, params: dict):
        """Ejecuta el algoritmo genético configurado con los parámetros proporcionados"""
        if not self.ga_executor:
            QMessageBox.critical(self, "Error", "No se ha configurado un ejecutor de Algoritmo Genético.")
            return

        # Mostrar un diálogo de progreso simple
        progress_dialog = QProgressDialog("Ejecutando AG...", "Cancelar", 0, 0, self)
        progress_dialog.setWindowModality(Qt.WindowModal)
        progress_dialog.setWindowTitle("Procesando")
        progress_dialog.show()
        # QApplication.processEvents() # Para que se muestre inmediatamente

        try:
            # Pasamos 'self' (la QMainWindow) como ventana padre para el AG,
            # por si el AG necesita crear sus propios diálogos de progreso Qt.
            results = self.ga_executor(params, self)

            if results is None:
                progress_dialog.close()
                return

            self.ga_results = results['ga_results']
            self.population_history = results['population_history']
            self.fitness_history = results['fitness_history']
            self.best_fitness_history = results['best_fitness_history']

            # Actualizar la función en la UI si el AG la reporta
            function_text_from_ga = self.ga_results.get('function_text_for_report')
            if function_text_from_ga:
                # Usamos el FunctionEditor de PySide6 para validar y obtener la función compilada
                temp_editor = FunctionEditor(self) # 'self' es el padre QMainWindow
                temp_editor.function_entry.setText(function_text_from_ga) # Asumimos que FunctionEditor tiene 'function_entry'
                is_valid = temp_editor.validate_function()
                if is_valid:
                    # Asumimos que validate_function en FunctionEditor actualiza self.compiled_function_result
                    self.ui_function_provider.set_function(function_text_from_ga, temp_editor.compiled_function_result)
                    self.config_panel.update_function_display() # ConfigPanel debe tener este método
                else:
                    QMessageBox.critical(self, "Error de Función",
                                         "La función reportada por el AG no pudo ser validada por la UI.")
                # temp_editor.destroy() # No es necesario, se cierra con el scope o si es modal
            else:
                QMessageBox.warning(self, "Advertencia", "El AG no reportó la función objetivo utilizada.")

            self.config_panel.enable_buttons() # ConfigPanel debe tener este método
            mode_text = "Minimización" if params['is_minimizing'] else "Maximización"
            QMessageBox.information(self, "Completado",
                                f"Algoritmo de ejemplo completado! ({mode_text})\n\n"
                                f"Mejor solución: x = {self.ga_results['best_x']:.6f}\n"
                                f"Mejor fitness (real): f(x) = {self.ga_results['best_fitness']:.6f}")

        except Exception as e:
            QMessageBox.critical(self, "Error en AG", f"Error durante la ejecución del AG: {str(e)}")
            import traceback
            traceback.print_exc()
        finally:
            progress_dialog.close()


    def generate_report(self): # Ya no necesita 'filename' como argumento directo
        if not self.ga_results:
            QMessageBox.warning(self, "Advertencia", "No hay resultados para generar el reporte.")
            return False

        # Usar QFileDialog para obtener el nombre del archivo
        filename, selected_filter = QFileDialog.getSaveFileName(
            self,
            "Guardar Reporte",
            "", # Directorio inicial (opcional)
            "Text files (*.txt);;All files (*.*)"
        )
        if not filename: # El usuario canceló
            return False

        try:
            self.report_generator.generate(
                filename,
                self.ga_results,
                self.best_fitness_history
            )
            QMessageBox.information(self, "Reporte Guardado", f"Reporte guardado en:\n{filename}")
            if QMessageBox.question(self, "Abrir Reporte", "¿Desea abrir el reporte generado?") == QMessageBox.Yes:
                open_file(filename) # Usar el helper
            return True
        except Exception as e:
            QMessageBox.critical(self, "Error de Reporte", f"Error al generar el reporte: {str(e)}")
            return False


    def save_animation(self): # Ya no necesita 'filename' como argumento directo
        if not self.ga_results:
            QMessageBox.warning(self, "Advertencia", "Primero debe ejecutar el algoritmo.")
            return False

        filename, selected_filter = QFileDialog.getSaveFileName(
            self,
            "Guardar Animación",
            "",
            "MP4 files (*.mp4);;GIF files (*.gif);;All files (*.*)"
        )
        if not filename:
            return False

        try:
            # El AnimationGenerator ya maneja su propio diálogo de progreso y QMessageBox
            # Pasamos 'self' como ventana raíz para que los diálogos del generador sean modales a esta.
            success = self.animation_generator.generate(
                filename,
                self.best_fitness_history,
                self.ga_results['is_minimizing'],
                self # QWidget padre para los diálogos del AnimationGenerator
            )
            # Nota: AnimationGenerator debería mostrar su propio QMessageBox de éxito/error
            return success
        except Exception as e:
            # Esto es un fallback si AnimationGenerator no maneja su propia excepción
            QMessageBox.critical(self, "Error de Animación", f"Error al generar la animación: {str(e)}")
            return False


    def clear_results(self):
        self.ga_results = None
        self.population_history = []
        self.fitness_history = []
        self.best_fitness_history = []
        self.visualization_panel.clear_graph_area()
        self.visualization_panel.create_welcome_message()  # Recrear mensaje de bienvenida

        if hasattr(self, 'config_panel') and self.config_panel:
            self.config_panel.disable_buttons()
            self.config_panel.update_graph_button_selection(None)  # Resetear selección visual de botones

        QMessageBox.information(self, "Resultados Limpiados", "Todos los resultados han sido limpiados.")

    # El método run() ya no es necesario aquí, QApplication.exec() en main.py lo maneja.

    def set_ga_executor(self, executor_func):
        self.ga_executor = executor_func

===== ui/config_panel.py =====

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Panel de configuración de la aplicación
"""
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QScrollArea, QDoubleSpinBox, QPushButton,
    QLabel, QMessageBox, QSpinBox, QRadioButton, QGroupBox # Añadido QGroupBox
)
from PySide6.QtUiTools import QUiLoader
from PySide6.QtCore import QFile, QIODevice, Qt # Añadido Qt para alineación
from utils.math_functions import set_function_provider
import numpy as np

class ConfigPanel(QWidget):
    """Clase que maneja el panel de configuración (izquierdo)"""

    def __init__(self, parent_widget, main_window, function_provider_instance):
        super().__init__(parent_widget)
        self.main_window = main_window
        self.function_provider = function_provider_instance
        set_function_provider(self.function_provider)

        # Inicializar TODOS los atributos de widgets a None ANTES de cargar la UI
        self.interval_a_spinbox = None
        self.interval_b_spinbox = None
        self.delta_x_spinbox = None
        self.pop_size_spinbox = None
        self.num_generations_spinbox = None
        self.prob_crossover_spinbox = None
        self.prob_mutation_i_spinbox = None
        self.prob_mutation_g_spinbox = None
        self.minimize_radio = None
        self.maximize_radio = None
        self.function_display_label = None
        self.num_points_label = None
        self.num_bits_label = None
        self.max_decimal_label = None
        self.editFunctionButton = None
        self.execute_ag_btn = None
        self.scrollable_widget_content = None

        # Nuevos botones
        self.objectiveGraphButton = None
        self.bestEvolutionGraphButton = None
        self.allEvolutionGraphButton = None
        self.animatedEvolutionButton = None
        self.generateReportButton = None
        self.downloadAnimationButton = None
        self.clearResultsButton = None
        self.graph_buttons_list = []


        ui_loaded_successfully = self.init_ui_from_designer()

        if ui_loaded_successfully:
            # Conecta señales
            if self.interval_a_spinbox:
                self.interval_a_spinbox.valueChanged.connect(self.update_calculated_values)
            if self.interval_b_spinbox: # Asegurarse de conectar todos los que afectan los cálculos
                self.interval_b_spinbox.valueChanged.connect(self.update_calculated_values)
            if self.delta_x_spinbox:   # Asegurarse de conectar todos los que afectan los cálculos
                self.delta_x_spinbox.valueChanged.connect(self.update_calculated_values)

            if self.editFunctionButton:
                self.editFunctionButton.clicked.connect(self.open_function_editor)
            if self.execute_ag_btn:
                self.execute_ag_btn.clicked.connect(self.run_example_algorithm_from_config)

            # Conexiones para nuevos botones
            if self.objectiveGraphButton:
                self.objectiveGraphButton.clicked.connect(lambda: self.show_graph_slot("objective"))
            if self.bestEvolutionGraphButton:
                self.bestEvolutionGraphButton.clicked.connect(lambda: self.show_graph_slot("evolution_best"))
            if self.allEvolutionGraphButton:
                self.allEvolutionGraphButton.clicked.connect(lambda: self.show_graph_slot("evolution_all"))
            if self.animatedEvolutionButton:
                self.animatedEvolutionButton.clicked.connect(self.start_animation_slot)

            if self.generateReportButton:
                self.generateReportButton.clicked.connect(self.generate_report_slot)
            if self.downloadAnimationButton:
                self.downloadAnimationButton.clicked.connect(self.save_animation_slot)
            if self.clearResultsButton:
                self.clearResultsButton.clicked.connect(self.clear_results_slot)


            self.update_function_display()
            self.update_calculated_values()
            self.disable_buttons() # Estado inicial de los botones
        else:
            print("ConfigPanel UI failed to load. Panel functionality will be limited.")
            self.disable_buttons()


    def init_ui_from_designer(self):
        outer_layout = QVBoxLayout(self)
        self.setLayout(outer_layout) # Establecer el layout para el ConfigPanel mismo
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        outer_layout.addWidget(scroll_area)

        loader = QUiLoader()
        ui_file_path = "ui/config_panel.ui"
        ui_file = QFile(ui_file_path)

        if not ui_file.open(QIODevice.ReadOnly):
            print(f"Cannot open UI file: {ui_file_path} - {ui_file.errorString()}")
            QMessageBox.critical(self, "UI Load Error", f"Could not load {ui_file_path}")
            return False

        # self.scrollable_widget_content será el QWidget raíz del archivo .ui
        self.scrollable_widget_content = loader.load(ui_file, self) # 'self' como padre
        ui_file.close()

        if not self.scrollable_widget_content:
            print(f"Error loading UI file {ui_file_path}: {loader.errorString()}")
            QMessageBox.critical(self, "UI Load Error", f"Error parsing {ui_file_path}: {loader.errorString()}")
            return False

        scroll_area.setWidget(self.scrollable_widget_content)

        # --- Acceso a widgets del .ui ---
        # Es crucial que los objectName aquí coincidan con tu config_panel.ui
        self.interval_a_spinbox = self.scrollable_widget_content.findChild(QDoubleSpinBox, "interval_a_spinbox")
        self.interval_b_spinbox = self.scrollable_widget_content.findChild(QDoubleSpinBox, "interval_b_spinbox")
        self.delta_x_spinbox = self.scrollable_widget_content.findChild(QDoubleSpinBox, "delta_x_spinbox")
        self.pop_size_spinbox = self.scrollable_widget_content.findChild(QSpinBox, "pop_size_spinbox")
        self.num_generations_spinbox = self.scrollable_widget_content.findChild(QSpinBox, "num_generations_spinbox")
        self.prob_crossover_spinbox = self.scrollable_widget_content.findChild(QDoubleSpinBox, "prob_crossover_spinbox")
        self.prob_mutation_i_spinbox = self.scrollable_widget_content.findChild(QDoubleSpinBox, "prob_mutation_i_spinbox")
        self.prob_mutation_g_spinbox = self.scrollable_widget_content.findChild(QDoubleSpinBox, "prob_mutation_g_spinbox")
        self.minimize_radio = self.scrollable_widget_content.findChild(QRadioButton, "minimize_radio")
        self.maximize_radio = self.scrollable_widget_content.findChild(QRadioButton, "maximize_radio")
        self.function_display_label = self.scrollable_widget_content.findChild(QLabel, "functionDisplayLabel")
        self.num_points_label = self.scrollable_widget_content.findChild(QLabel, "num_points_label")
        self.num_bits_label = self.scrollable_widget_content.findChild(QLabel, "num_bits_label")
        self.max_decimal_label = self.scrollable_widget_content.findChild(QLabel, "max_decimal_label")
        self.editFunctionButton = self.scrollable_widget_content.findChild(QPushButton, "editFunctionButton")
        self.execute_ag_btn = self.scrollable_widget_content.findChild(QPushButton, "execute_ag_btn")

        # --- Añadir los botones faltantes programáticamente ---
        # Necesitamos el layout principal del widget cargado desde el .ui
        # Asumimos que es un QVBoxLayout y se llama "mainVerticalLayout" en el .ui
        loaded_ui_main_layout = self.scrollable_widget_content.layout() # Obtener el layout del widget cargado

        if not loaded_ui_main_layout:
            print("ERROR: El widget cargado desde config_panel.ui no tiene un layout principal (ej. 'mainVerticalLayout'). No se pueden añadir botones.")
            return False # O manejar el error de otra forma

        # --- Grupo: Seleccionar Gráfica ---
        graph_selection_group = QGroupBox("Seleccionar Gráfica")
        graph_selection_layout = QVBoxLayout()
        graph_selection_group.setLayout(graph_selection_layout)

        self.objectiveGraphButton = QPushButton("Función Objetivo")
        self.objectiveGraphButton.setObjectName("objectiveGraphButton")
        graph_selection_layout.addWidget(self.objectiveGraphButton)
        self.graph_buttons_list.append(self.objectiveGraphButton)

        self.bestEvolutionGraphButton = QPushButton("Evolución Mejor")
        self.bestEvolutionGraphButton.setObjectName("bestEvolutionGraphButton")
        graph_selection_layout.addWidget(self.bestEvolutionGraphButton)
        self.graph_buttons_list.append(self.bestEvolutionGraphButton)

        self.allEvolutionGraphButton = QPushButton("Evolución Población")
        self.allEvolutionGraphButton.setObjectName("allEvolutionGraphButton")
        graph_selection_layout.addWidget(self.allEvolutionGraphButton)
        self.graph_buttons_list.append(self.allEvolutionGraphButton)

        self.animatedEvolutionButton = QPushButton("Evolución Animada")
        self.animatedEvolutionButton.setObjectName("animatedEvolutionButton")
        graph_selection_layout.addWidget(self.animatedEvolutionButton)
        self.graph_buttons_list.append(self.animatedEvolutionButton) # Este también es un botón de "gráfica"

        # Añadir el grupo al layout principal del contenido cargado
        # Intentar insertarlo antes del spacer final si existe
        spacer_item = None
        for i in range(loaded_ui_main_layout.count()):
            item = loaded_ui_main_layout.itemAt(i)
            if item.spacerItem():
                spacer_item = item
                break
        
        if spacer_item:
            loaded_ui_main_layout.insertWidget(loaded_ui_main_layout.indexOf(spacer_item), graph_selection_group)
        else:
            loaded_ui_main_layout.addWidget(graph_selection_group)


        # --- Grupo: Acciones ---
        actions_group = QGroupBox("Acciones")
        actions_layout = QVBoxLayout()
        actions_group.setLayout(actions_layout)

        self.generateReportButton = QPushButton("Generar Reporte")
        self.generateReportButton.setObjectName("generateReportButton")
        actions_layout.addWidget(self.generateReportButton)

        self.downloadAnimationButton = QPushButton("Descargar Animación")
        self.downloadAnimationButton.setObjectName("downloadAnimationButton")
        actions_layout.addWidget(self.downloadAnimationButton)

        self.clearResultsButton = QPushButton("Limpiar Resultados")
        self.clearResultsButton.setObjectName("clearResultsButton")
        actions_layout.addWidget(self.clearResultsButton)

        if spacer_item:
            loaded_ui_main_layout.insertWidget(loaded_ui_main_layout.indexOf(spacer_item), actions_group)
        else:
            loaded_ui_main_layout.addWidget(actions_group)


        # Verificar que los widgets del .ui se encontraron
        essential_widgets_from_ui = {
            "interval_a_spinbox": self.interval_a_spinbox,
            "interval_b_spinbox": self.interval_b_spinbox,
            # ... (añade aquí todos los widgets que DEBEN existir del .ui)
            "execute_ag_btn": self.execute_ag_btn
        }
        for name, widget_instance in essential_widgets_from_ui.items():
            if not widget_instance:
                print(f"CRITICAL WARNING: UI-defined widget '{name}' not found. Check objectName in config_panel.ui.")
                # return False # Podrías fallar aquí si son indispensables
        return True


    def open_function_editor(self):
        from ui.function_editor import FunctionEditor
        editor = FunctionEditor(self) # 'self' (ConfigPanel) es el padre

        if self.function_provider and self.function_provider.function_text:
            editor.function_entry.setText(self.function_provider.function_text)
        elif hasattr(editor, 'default_function'): # Si FunctionEditor tiene un default
             editor.function_entry.setText(editor.default_function)


        def on_function_accept_wrapper(function_text, compiled_function):
            if self.function_provider:
                self.function_provider.set_function(function_text, compiled_function)
                self.update_function_display()
                QMessageBox.information(self, "Función Actualizada",
                                      "La función objetivo ha sido actualizada.")
            else:
                QMessageBox.warning(self, "Error", "Function provider no disponible.")

        editor.callback_function = on_function_accept_wrapper
        editor.exec()


    def update_function_display(self):
        if self.function_display_label and self.function_provider:
            function_text = self.function_provider.function_text
            display_text = function_text.replace('*', '·')
            self.function_display_label.setText(f"f(x) = {display_text}")
        elif not self.function_display_label:
            print("Warning: functionDisplayLabel not found for update.")


    def update_calculated_values(self):
        required_spinboxes = [self.interval_a_spinbox, self.interval_b_spinbox, self.delta_x_spinbox]
        required_labels = [self.num_points_label, self.num_bits_label, self.max_decimal_label]

        if not all(s for s in required_spinboxes) or not all(l for l in required_labels):
            if self.num_points_label: self.num_points_label.setText("...")
            if self.num_bits_label: self.num_bits_label.setText("...")
            if self.max_decimal_label: self.max_decimal_label.setText("...")
            return

        try:
            x_min = self.interval_a_spinbox.value()
            x_max = self.interval_b_spinbox.value()
            delta_x = self.delta_x_spinbox.value()

            if x_max > x_min and delta_x > 0:
                n_bits = 0
                if x_min == 0 and x_max == 31 and delta_x == 1.0:
                    n_bits = 5
                elif x_min >= 0 and x_max == int(x_max) and delta_x == 1.0:
                    range_size = int(x_max - x_min) + 1
                    n_bits = (range_size -1 ).bit_length() if range_size > 0 else 0
                else:
                    num_divisions = int(np.round((x_max - x_min) / delta_x))
                    n_bits = (num_divisions).bit_length() if num_divisions >= 0 else 0
                
                if n_bits == 0 and ((x_max - x_min) > 0 or (x_min == x_max and delta_x > 0)): # Si hay rango o un solo punto definido por delta_x
                    n_bits = max(1, n_bits)
                if x_min == x_max and n_bits == 1: # Un solo punto, 0 bits es más correcto para 1 valor.
                    n_bits = 0


                max_decimal = (2**n_bits - 1) if n_bits > 0 else 0
                num_points = max_decimal + 1

                self.num_points_label.setText(str(num_points))
                self.num_bits_label.setText(str(n_bits))
                self.max_decimal_label.setText(str(max_decimal))
            else:
                self.num_points_label.setText("...")
                self.num_bits_label.setText("...")
                self.max_decimal_label.setText("...")
        except Exception as e:
            print(f"Error in update_calculated_values: {e}")
            import traceback
            traceback.print_exc()
            if self.num_points_label: self.num_points_label.setText("Error")
            if self.num_bits_label: self.num_bits_label.setText("Error")
            if self.max_decimal_label: self.max_decimal_label.setText("Error")


    def run_example_algorithm_from_config(self):
        required_widgets_for_run = [
            self.interval_a_spinbox, self.interval_b_spinbox, self.delta_x_spinbox,
            self.pop_size_spinbox, self.num_generations_spinbox, self.prob_crossover_spinbox,
            self.prob_mutation_i_spinbox, self.prob_mutation_g_spinbox, self.minimize_radio
        ]
        if not all(w for w in required_widgets_for_run):
            QMessageBox.critical(self, "Error de Configuración", "Faltan componentes de UI. Verifique objectNames en .ui y código.")
            return

        params = {
            'interval_a': self.interval_a_spinbox.value(),
            'interval_b': self.interval_b_spinbox.value(),
            'delta_x': self.delta_x_spinbox.value(),
            'pop_size': self.pop_size_spinbox.value(),
            'num_generations': self.num_generations_spinbox.value(),
            'prob_crossover': self.prob_crossover_spinbox.value(),
            'prob_mutation_i': self.prob_mutation_i_spinbox.value(),
            'prob_mutation_g': self.prob_mutation_g_spinbox.value(),
            'is_minimizing': self.minimize_radio.isChecked() if self.minimize_radio else True
        }
        if self.main_window:
            self.main_window.run_example_algorithm(params)
        else:
            QMessageBox.critical(self, "Error Interno", "Referencia a MainWindow no encontrada.")

    # --- Métodos _slot para los nuevos botones ---
    def show_graph_slot(self, graph_type: str):
        if not self.main_window or not self.main_window.ga_results:
            QMessageBox.warning(self, "Advertencia", "Primero debe ejecutar el algoritmo.")
            return
        self.update_graph_button_selection(graph_type)
        if hasattr(self.main_window, 'visualization_panel'):
            self.main_window.visualization_panel.show_graph(
                graph_type,
                self.main_window.ga_results,
                self.main_window.population_history,
                self.main_window.fitness_history,
                self.main_window.best_fitness_history
            )

    def start_animation_slot(self):
        if not self.main_window or not self.main_window.ga_results:
            QMessageBox.warning(self, "Advertencia", "Primero debe ejecutar el algoritmo.")
            return
        
        vis_panel = self.main_window.visualization_panel
        if vis_panel.is_animating:
            if self.animatedEvolutionButton: self.animatedEvolutionButton.setText("Evolución Animada")
            vis_panel.stop_animation()
            self.update_graph_button_selection(None) # Puede que quieras seleccionar la última gráfica estática vista
        else:
            if self.animatedEvolutionButton: self.animatedEvolutionButton.setText("Detener Animación")
            self.update_graph_button_selection("animation") # Un tipo especial para la animación
            vis_panel.start_animation(
                self.main_window.best_fitness_history,
                self.main_window.ga_results['is_minimizing']
            )

    def generate_report_slot(self):
        if self.main_window: self.main_window.generate_report()

    def save_animation_slot(self):
        if self.main_window: self.main_window.save_animation()

    def clear_results_slot(self):
        if self.main_window: self.main_window.clear_results()
        # MainWindow.clear_results ya llama a self.config_panel.disable_buttons()
        # y debería llamar a self.update_graph_button_selection(None)

    def update_graph_button_selection(self, selected_type: str | None):
        buttons_map = {
            "objective": self.objectiveGraphButton,
            "evolution_best": self.bestEvolutionGraphButton,
            "evolution_all": self.allEvolutionGraphButton,
            # "animation" es un caso especial
        }
        for graph_name, button_widget in buttons_map.items():
            if button_widget:
                is_selected = (graph_name == selected_type)
                button_widget.setProperty("selected", is_selected)
                button_widget.style().unpolish(button_widget)
                button_widget.style().polish(button_widget)

        if self.animatedEvolutionButton:
            is_anim_selected = (selected_type == "animation" or (self.main_window and self.main_window.visualization_panel.is_animating))
            self.animatedEvolutionButton.setProperty("selected", is_anim_selected)
            if self.main_window and self.main_window.visualization_panel.is_animating :
                 self.animatedEvolutionButton.setText("Detener Animación")
            else:
                 self.animatedEvolutionButton.setText("Evolución Animada")

            self.animatedEvolutionButton.style().unpolish(self.animatedEvolutionButton)
            self.animatedEvolutionButton.style().polish(self.animatedEvolutionButton)


    def enable_buttons(self):
        # Habilita botones basados en si hay resultados o no
        has_results = self.main_window and self.main_window.ga_results is not None

        if self.execute_ag_btn: self.execute_ag_btn.setEnabled(True) # Siempre habilitado?
        if self.editFunctionButton: self.editFunctionButton.setEnabled(True) # Siempre habilitado?

        for btn in self.graph_buttons_list:
            if btn: btn.setEnabled(has_results)
        
        if self.generateReportButton: self.generateReportButton.setEnabled(has_results)
        if self.downloadAnimationButton: self.downloadAnimationButton.setEnabled(has_results)
        if self.clearResultsButton: self.clearResultsButton.setEnabled(True) # Siempre habilitado para limpiar
        
        if has_results:
            # Si hay resultados, pero ninguna gráfica seleccionada, podrías seleccionar una por defecto
            # self.update_graph_button_selection("objective") # O la que prefieras
            pass
        else:
             self.update_graph_button_selection(None)


    def disable_buttons(self):
        # Este método se llama al inicio y cuando se limpian los resultados.
        # El botón de ejecutar y editar función deberían estar siempre habilitados.
        if self.execute_ag_btn: self.execute_ag_btn.setEnabled(True)
        if self.editFunctionButton: self.editFunctionButton.setEnabled(True)

        # Los botones de gráficas y acciones se deshabilitan si no hay resultados.
        for btn in self.graph_buttons_list:
            if btn: btn.setEnabled(False)
        
        if self.generateReportButton: self.generateReportButton.setEnabled(False)
        if self.downloadAnimationButton: self.downloadAnimationButton.setEnabled(False)
        
        # El botón de limpiar podría estar siempre habilitado, o deshabilitarse si no hay nada que limpiar.
        # Lo dejamos habilitado por simplicidad, MainWindow puede decidir si realmente limpia.
        if self.clearResultsButton: self.clearResultsButton.setEnabled(True) 
        
        self.update_graph_button_selection(None) # Resetear selección visual